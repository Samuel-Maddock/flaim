from typing import List
from collections import defaultdict

import numpy as np

from synth_fl.utils import logger, DEFAULT_DATA_ROOT
from synth_fl.utils.dataloaders import TabularDataset
from synth_fl.utils.privacy import (
    ExponentialMechanism,
    GaussianMechanism,
    LaplaceMechanism,
    zCDPAccountant,
    AutoDPAccountant,
)

from synth_fl.libs.private_pgm.mechanisms.aim import AIM as _AIM

from synth_fl.generators.central import GeneratorConfig
from synth_fl.generators import Generator

from typing import Tuple


class BaseAIM(Generator):
    def __init__(
        self,
        config: GeneratorConfig,
        disable_cdp_init=False,
    ) -> None:
        super().__init__(config)
        self.name = "aim"

        # Initialise accountant and mechanisms
        # Used to improve init performance in FLAIM
        rho = 0 if disable_cdp_init else None
        self.accountant_type = self.config.accountant_type
        self.subsample_rate = 1  # no subsampling

        if self.accountant_type == "zcdp":
            self.accountant = zCDPAccountant(
                self.config.epsilon, self.config.delta, rho
            )
        else:
            self.accountant = AutoDPAccountant(
                self.config.epsilon,
                self.config.delta,
                sample_rate=self.subsample_rate,
            )

        if config.aim_mech == "gaussian":
            self.gauss_mech = GaussianMechanism(self.accountant)
        else:
            self.gauss_mech = LaplaceMechanism(self.accountant)
        self.exp_mech = ExponentialMechanism(self.accountant)

        self.init_gauss_sigma, self.init_exp_epsilon = None, None
        self.anneal_type = config.anneal_type
        self.model = None  # PGM Model

        self.pgm_train_iters = config.pgm_train_iters
        self.pgm_final_iters = config.pgm_final_iters
        self.pgm_weight_method = config.pgm_weight_method
        self.global_rounds = config.global_rounds
        self.adaptive_noise = True if not self.global_rounds else False
        self.gauss_budget_alloc = config.gauss_budget_alloc
        self.exp_budget_alloc = 1 - self.gauss_budget_alloc

        # Override to change num of synth data rows generated by PGM
        self.synth_rows = None

        # Attributes used by child classes
        self.rounds = None
        self.num_oneways = None
        self.n = None
        self.normalize_measurements = config.normalize_measurements

        self.decision_map = defaultdict(list)
        self.log_decisions = config.log_decisions
        self.client_answers_dtype = "uint16"  # todo

        if self.backend_model == "rap":
            self.normalize_measurements = True

        # RAPConfig args
        self.categorical_consistency = True
        self.n_prime = 1000
        # self.sgd_iters = 5000  # 1000 # SGD iters
        self.sgd_iters = 50
        self.learning_rate = 1e-3
        self.lambda_l1 = 0
        self.k = 3
        self.top_q = 1
        self.stopping_condition = 10**-7
        self.initialize_binomial = False
        self.norm = "L2"

        self.internal_metrics["actual_rounds"] = 0

    # Generator methods
    def _generate(self, dataset, workload):
        # Convert datasets to PGM datasets to use .project()
        aim = _AIM(self.config.epsilon, self.config.delta, self.global_rounds, enable_logging=True)
        aim_results = aim.run(dataset[0].to_pgm_dataset(), self._format_workload(workload))
        return aim_results

    def _format_workload(self, workload: np.array) -> List[Tuple[np.array, int]]:
        # TODO: Change AIM to only take w instead of (w, 1.0)
        return [(w, 1.0) for w in workload]

    def generate(
        self, dataset: TabularDataset, workload=None, **kwargs
    ) -> TabularDataset:
        assert workload is not None
        self.n = dataset.n
        # workload = self._format_workload(workload)
        aim_results = self._generate([dataset], workload)
        return TabularDataset(
            f"{self.name} {dataset.name}", None, aim_results[1], dataset.domain
        )
